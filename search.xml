<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[【ApplicationContextInitializer】springboot如何在所有bean初始化之前加载一个自定义类]]></title>
    <url>%2F2017%2F11%2F27%2F%E3%80%90ApplicationContextInitializer%E3%80%91springboot%E5%A6%82%E4%BD%95%E5%9C%A8%E6%89%80%E6%9C%89bean%E5%88%9D%E5%A7%8B%E5%8C%96%E4%B9%8B%E5%89%8D%E5%8A%A0%E8%BD%BD%E4%B8%80%E4%B8%AA%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[【ApplicationContextInitializer】springboot如何在所有bean初始化之前加载一个自定义类 ApplicationContextInitializer使用步骤 实现ApplicationContextInitializer接口； 将ApplicationContextInitializer实现类添加到Springboot中执行； 自定义 ApplicationContextInitializer示例：在所有bean创建之前，添加一个yaml属性源;123456789101112131415161718192021222324252627package com.ssslinppp.contextInitializer;import org.springframework.boot.env.YamlPropertySourceLoader;import org.springframework.context.ApplicationContextInitializer;import org.springframework.context.ConfigurableApplicationContext;import org.springframework.context.annotation.Configuration;import org.springframework.core.env.PropertySource;import org.springframework.core.io.ClassPathResource;import org.springframework.core.io.Resource;import java.io.IOException;@Configurationpublic class YamlFileApplicationContextInitializer implements ApplicationContextInitializer&lt;ConfigurableApplicationContext&gt; &#123; @Override public void initialize(ConfigurableApplicationContext applicationContext) &#123; try &#123;// Resource resource = applicationContext.getResource(&quot;classpath:/config/myConfig.yml&quot;); Resource resource = new ClassPathResource(&quot;/config/myConfig.yml&quot;); YamlPropertySourceLoader sourceLoader = new YamlPropertySourceLoader(); PropertySource&lt;?&gt; yamlTestProperties = sourceLoader.load(&quot;yaml&quot;, resource, null); applicationContext.getEnvironment().getPropertySources().addFirst(yamlTestProperties); &#125; catch (IOException e) &#123; throw new RuntimeException(e); &#125; &#125;&#125; 添加ApplicationContextInitializer实现类到Springboot中方式1： spring.factories文件中定义文件位置：src/main/java/resources/META-INF/spring.factories文件内容：12org.springframework.context.ApplicationContextInitializer=\ com.ssslinppp.contextInitializer.YamlFileApplicationContextInitializer 方式2：使用SpringApplication.addInitializers()123456public static void main(String[] args) &#123; SpringApplication springApplication = new SpringApplication(YamlApplication.class); //关键一步：将一个或多个initializer加入至spring容器中 springApplication.addInitializers(new YamlFileApplicationContextInitializer()); springApplication.run(args);&#125; 方式3：在application.properties中配置1context.initializer.classes=com.ssslinppp.contextInitializer.YamlFileApplicationContextInitializer]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>ApplicationContextInitializer</tag>
        <tag>Springboot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【XML读写】使用Java POJO实现XML文件的读写]]></title>
    <url>%2F2017%2F11%2F21%2F%E3%80%90XML%E8%AF%BB%E5%86%99%E3%80%91%E4%BD%BF%E7%94%A8Java%20POJO%E5%AE%9E%E7%8E%B0XML%E6%96%87%E4%BB%B6%E7%9A%84%E8%AF%BB%E5%86%99%2F</url>
    <content type="text"><![CDATA[读写XML使用fasterxml实现XML文件的读写操作。完全使用注解的方式读取XML内容，使用方便。 Step1：将Java POJO对象写入到XML文件，文件内容如下1234567891011121314151617181920212223&lt;schema name="post" version="1.5"&gt; &lt;uniqueKey&gt;post_id&lt;/uniqueKey&gt; &lt;types&gt; &lt;fieldType className="java.lang.Long" name="Long"/&gt; &lt;fieldType className="java.lang.String" name="String"/&gt; &lt;fieldType className="xxx.yyy.text" name="Text"/&gt; &lt;analyzer tokenizerClass="solr.StandartTokenizerFactory" type="index"/&gt; &lt;analyzer tokenizerClass="solr.StandartTokenizerFactory" type="query"/&gt; &lt;/types&gt; &lt;fields&gt; &lt;field name="post_id" required="true" type="Long"&gt;唯一标示&lt;/field&gt; &lt;field name="post_title" required="true" type="String"&gt;标题&lt;/field&gt; &lt;field name="post_context" required="false" type="Text"&gt;内容&lt;/field&gt; &lt;/fields&gt; &lt;copyField dest="text" source="post_content"/&gt; &lt;copyField dest="text" source="post_content"/&gt; &lt;copyField dest="text" source="section_name"/&gt; &lt;MyMap&gt; &lt;keyA&gt;valueA&lt;/keyA&gt; &lt;keyB&gt;valueB&lt;/keyB&gt; &lt;keyC&gt;valueC&lt;/keyC&gt; &lt;/MyMap&gt;&lt;/schema&gt; Step2: 读取Step1产生的XML到POJO对象中 具体步骤依赖XML转换使用的依赖12345678910&lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.dataformat&lt;/groupId&gt; &lt;artifactId&gt;jackson-dataformat-xml&lt;/artifactId&gt; &lt;version&gt;2.9.0&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.codehaus.woodstox&lt;/groupId&gt; &lt;artifactId&gt;woodstox-core-asl&lt;/artifactId&gt; &lt;version&gt;4.4.1&lt;/version&gt;&lt;/dependency&gt; 工具包：1234567891011&lt;dependency&gt; &lt;groupId&gt;com.google.guava&lt;/groupId&gt; &lt;artifactId&gt;guava&lt;/artifactId&gt; &lt;version&gt;19.0&lt;/version&gt;&lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;version&gt;1.16.18&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt;&lt;/dependency&gt; 构建XmlMapper 构建JacksonXmlModule； 设置JacksonXmlModule属性； 创建XmlMapper，并设置JacksonXmlModule以及修改配置；12345678910111213private ObjectMapper getXMLMapper() &#123; //The Jackson XML module supports the full range of annotations that Jackson provides for annotating our POJOs. //The Jackson XML module adds some additional support for XML specific features JacksonXmlModule module = new JacksonXmlModule(); module.setDefaultUseWrapper(false); //As of version 2.9.0, this is the only configuration options for the XML Module ObjectMapper xmlMapper = new XmlMapper(module); xmlMapper.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, Boolean.FALSE); xmlMapper.configure(DeserializationFeature.ACCEPT_SINGLE_VALUE_AS_ARRAY, Boolean.TRUE); xmlMapper.configure(DeserializationFeature.ACCEPT_EMPTY_STRING_AS_NULL_OBJECT, Boolean.TRUE); xmlMapper.configure(DeserializationFeature.FAIL_ON_INVALID_SUBTYPE, Boolean.TRUE); return xmlMapper;&#125; 主要注解@JacksonXmlRootElement(localName = “schema”)设置XML根节点名称123&lt;schema&gt; ...&lt;/schema&gt; @JacksonXmlProperty(isAttribute = true)作为XML的属性存在，而不是节点存在12345@JacksonXmlProperty(isAttribute = true) /* 作为XML的属性存在，而不是节点存在 */private String name;@JacksonXmlProperty(isAttribute = true) /* 作为XML的属性存在，而不是节点存在 */private double version; 对用的XML：12&lt;schema name=&quot;post&quot; version=&quot;1.5&quot;&gt;&lt;/schema&gt; @JacksonXmlElementWrapper(localName = “fields”)主要用于集合，如List,Array,Collection等，123@JacksonXmlElementWrapper(localName = &quot;fields&quot;)@JsonProperty(&quot;field&quot;)private List&lt;Field&gt; fieldList = Lists.newArrayList(); 对应的XML12345&lt;fields&gt; &lt;field name=&quot;post_id&quot; required=&quot;true&quot; type=&quot;Long&quot;&gt;唯一标示&lt;/field&gt; &lt;field name=&quot;post_title&quot; required=&quot;true&quot; type=&quot;String&quot;&gt;标题&lt;/field&gt; &lt;field name=&quot;post_context&quot; required=&quot;false&quot; type=&quot;Text&quot;&gt;内容&lt;/field&gt;&lt;/fields&gt; @JsonProperty(“copyField”)设置别名，没有使用 @JacksonXmlElementWrapper对List进行包装12@JsonProperty(&quot;copyField&quot;)private List&lt;CopyField&gt; copyFields = Lists.newArrayList(); 对应的XML123&lt;copyField dest=&quot;text&quot; source=&quot;post_content&quot;/&gt;&lt;copyField dest=&quot;text&quot; source=&quot;post_content&quot;/&gt;&lt;copyField dest=&quot;text&quot; source=&quot;section_name&quot;/&gt; @JsonPropertyOrder({“uniqueKey”, “types”})指定输出到XML文件时，各节点的顺序 完整代码和参考链接代码]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>xml</tag>
        <tag>xmlmapper</tag>
        <tag>fasterxml</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OrientDB-JDBC-驱动注册与连接获取-源码分析]]></title>
    <url>%2F2017%2F11%2F02%2FOrientDB-JDBC-%E9%A9%B1%E5%8A%A8%E6%B3%A8%E5%86%8C%E4%B8%8E%E8%BF%9E%E6%8E%A5%E8%8E%B7%E5%8F%96-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[驱动注册 DriverManager管理所有的JdbcDriver； Driver实现类（OrientJdbcDriver）：所有实现类都需要注册到DriverManage中； Class.forName(“xxxx”): 使用反射实现所有的Driver注册； DriverManagerJava中使用DriverManager来管理所有的JDBC驱动，每一个新添加的JDBCDriver都需要首先注册到DriverManager中，DriverManager使用：1private final static CopyOnWriteArrayList&lt;DriverInfo&gt; registeredDrivers = new CopyOnWriteArrayList&lt;&gt;(); 来管理所有注册的驱动，DriverManager提供了注册方法，如下：123456789101112131415public static synchronized void registerDriver(java.sql.Driver driver, DriverAction da) throws SQLException &#123; /* Register the driver if it has not already been added to our list */ if(driver != null) &#123; registeredDrivers.addIfAbsent(new DriverInfo(driver, da)); &#125; else &#123; // This is for compatibility with the original DriverManager throw new NullPointerException(); &#125; println(&quot;registerDriver: &quot; + driver); &#125; OrientJdbcDriverDriver官方接口文档中，指明驱动注册方法: Class.forName(&quot;foo.bah.Driver&quot;)12345* &lt;P&gt;When a Driver class is loaded, it should create an instance of* itself and register it with the DriverManager. This means that a* user can load and register a driver by calling:* &lt;p&gt;* &#123;@code Class.forName(&quot;foo.bah.Driver&quot;)&#125; OrientJdbcDriver源码中代码：使用static块实现驱动的注册12345678910public class OrientJdbcDriver implements java.sql.Driver &#123; static &#123; try &#123; DriverManager.registerDriver(new OrientJdbcDriver()); &#125; catch (SQLException e) &#123; OLogManager.instance().error(null, &quot;Error while registering the JDBC Driver&quot;, e); &#125; &#125; ...&#125; Class.forName(“xxxx”)Java后台代码如果新增驱动，则只需要使用：1Class.forName(OrientJdbcDriver.class.getName()); 即可完成驱动注册： 通过反射创建XXXDriver的实例； 该实例会自动调用 static 块，实现驱动的注册； 使用DriverManage获取ConnectionDriverManager.getConnection(xxx,xxx)123456789101112String url = &quot;jdbc:orient:remote:192.168.35.129/demo&quot;;Properties info = new Properties();String user = &quot;root&quot;;String password = &quot;root&quot;;info.put(&quot;user&quot;, user);info.put(&quot;password&quot;, password);info.put(&quot;db.usePool&quot;, true);info.put(&quot;db.pool.min&quot;, &quot;3&quot;); // MINIMUM POOL SIZEinfo.put(&quot;db.pool.max&quot;, &quot;30&quot;); // MAXIMUM POOL SIZEConnection connection = (OrientJdbcConnection) DriverManager.getConnection(url, info); DriverManager.getConnection()源码分析 首先获取ClassLoader； 遍历所有注册的Drivers（registeredDrivers）； 依次调用这些Driver的connect()方法，直到获取到相应的Connection才结束；123456789101112131415161718192021222324252627282930313233343536373839404142private static Connection getConnection( String url, java.util.Properties info, Class&lt;?&gt; caller) throws SQLException &#123; // 获取ClassLoader ClassLoader callerCL = caller != null ? caller.getClassLoader() : null; synchronized(DriverManager.class) &#123; // synchronize loading of the correct classloader. if (callerCL == null) &#123; callerCL = Thread.currentThread().getContextClassLoader(); &#125; &#125; if(url == null) &#123; throw new SQLException(&quot;The url cannot be null&quot;, &quot;08001&quot;); &#125; SQLException reason = null; // 遍历所有已注册Driver，依次调用方法connection()，直到获取到Connection for(DriverInfo aDriver : registeredDrivers) &#123; if(isDriverAllowed(aDriver.driver, callerCL)) &#123; try &#123; Connection con = aDriver.driver.connect(url, info); if (con != null) &#123; return (con); &#125; &#125; catch (SQLException ex) &#123; if (reason == null) &#123; reason = ex; &#125; &#125; &#125; else &#123; println(&quot; skipping: &quot; + aDriver.getClass().getName()); &#125; &#125; // if we got here nobody could connect. if (reason != null) &#123; throw reason; &#125; throw new SQLException(&quot;No suitable driver found for &quot;+ url, &quot;08001&quot;); &#125; OrientJdbcDriver获取Connection 获取user和passwd； 判断是否使用数据库连接池(pool); 获取连接； 源码如下：123456789101112131415161718192021222324252627public Connection connect(String url, Properties info) throws SQLException &#123; if (!acceptsURL(url)) return null; return new OrientJdbcConnection(url, info);&#125;public OrientJdbcConnection(final String jdbcdDUrl, final Properties info) &#123; this.dbUrl = jdbcdDUrl.replace(&quot;jdbc:orient:&quot;, &quot;&quot;); this.info = info; readOnly = false; final String username = info.getProperty(&quot;user&quot;, &quot;admin&quot;); final String password = info.getProperty(&quot;password&quot;, &quot;admin&quot;); usePool = Boolean.parseBoolean(info.getProperty(&quot;db.usePool&quot;, &quot;false&quot;)); if (usePool) &#123; OPartitionedDatabasePool pool = POOL_FACTORY.get(dbUrl, username, password); database = pool.acquire(); &#125; else &#123; database = new ODatabaseDocumentTx(this.dbUrl); database.open(username, password); database.activateOnCurrentThread(); &#125; status = ODatabase.STATUS.OPEN; &#125; orientDB数据库连接池的使用PoolIdentity PoolIdentity包括3个属性，url,user,userPassword, 简单理解：每个databaseUrl对应一个pool； PoolIdentity：不可变对象； 1private final ConcurrentLinkedHashMap&lt;PoolIdentity, OPartitionedDatabasePool&gt; poolStore; 需要说明的是： HashMap中的Key值，一般使用String或不可变对象，此时就需要PoolIdentity为不可变实现； HashMap的Key值，hashcode()的返回结果应尽量均匀分布； 看看源码中的实现： 使用final声明为不可变对象； 只有构造函数，没有setter之类的方法； ==&gt; 从而保证作为Key时，hashcode()不会改变； hashcode()重新实现：具体实现不做分析，目的是为了保证hash值平均分布； 1234567891011121314151617181920212223242526272829303132333435363738private static final class PoolIdentity &#123; private final String url; private final String userName; private final String userPassword; private PoolIdentity(final String url, final String userName, final String userPassword) &#123; this.url = url; this.userName = userName; this.userPassword = userPassword; &#125; @Override public boolean equals(final Object o) &#123; if (this == o) return true; if (o == null || getClass() != o.getClass()) return false; final PoolIdentity that = (PoolIdentity) o; if (!url.equals(that.url)) return false; if (!userName.equals(that.userName)) return false; if (!userPassword.equals(that.userPassword)) return false; return true; &#125; @Override public int hashCode() &#123; int result = url.hashCode(); result = 31 * result + userName.hashCode(); result = 31 * result + userPassword.hashCode(); return result; &#125; &#125;]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>orientDB</tag>
        <tag>nosql</tag>
        <tag>sql</tag>
        <tag>DriverManager</tag>
        <tag>orientdb-jdbc</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OrientDB常用SQL]]></title>
    <url>%2F2017%2F10%2F31%2ForientDB%E5%B8%B8%E7%94%A8sql%E8%AF%AD%E5%8F%A5%2F</url>
    <content type="text"><![CDATA[概述本文简单的介绍了一些常用的orientDB查询语句，仅供参考。 查询语句Record attributestoJson()123456789orientdb &#123;db=demo&#125;&gt; select @this.toJSON() from ouser+----+------------------------------------------------------------------------------------------------------------------------------------+|# |this |+----+------------------------------------------------------------------------------------------------------------------------------------+|0 |&#123;&quot;@type&quot;:&quot;d&quot;,&quot;@rid&quot;:&quot;#5:0&quot;,&quot;@version&quot;:1,&quot;@class&quot;:&quot;OUser&quot;,&quot;name&quot;:&quot;admin&quot;,&quot;password&quot;:&quot;&#123;PBKDF2WithHmacSHA256&#125;F094D23F35FDBF203FA9CFF...||1 |&#123;&quot;@type&quot;:&quot;d&quot;,&quot;@rid&quot;:&quot;#5:1&quot;,&quot;@version&quot;:1,&quot;@class&quot;:&quot;OUser&quot;,&quot;name&quot;:&quot;reader&quot;,&quot;password&quot;:&quot;&#123;PBKDF2WithHmacSHA256&#125;D69C58952FFC2F66BBD174...||2 |&#123;&quot;@type&quot;:&quot;d&quot;,&quot;@rid&quot;:&quot;#5:2&quot;,&quot;@version&quot;:1,&quot;@class&quot;:&quot;OUser&quot;,&quot;name&quot;:&quot;writer&quot;,&quot;password&quot;:&quot;&#123;PBKDF2WithHmacSHA256&#125;B8369621F7917A4850F356...|+----+------------------------------------------------------------------------------------------------------------------------------------+ @rid12select from Profile where @rid = #10:44 (不推荐，比较慢)select from #10:44 (推荐) @fields123456789orientdb &#123;db=demo&#125;&gt; select @fields from ouser +----+----------------------------+|# |fields |+----+----------------------------+|0 |[name,password,status,roles]||1 |[name,password,status,roles]||2 |[name,password,status,roles]|+----+----------------------------+ @sizereturns the record size in bytes123456789orientdb &#123;db=demo&#125;&gt; select @size from ouser +----+----+|# |size|+----+----+|0 |171 ||1 |172 ||2 |172 |+----+----+ @classMathematics Operators1select eval( &quot;amount * 120 / 100 - discount&quot; ) as finalPrice from Order Aggregated mode1SELECT SUM(salary) FROM employee expand()12345678orientdb &#123;db=demo&#125;&gt; select from #5:0 +----+----+------+-----+------+------+------------------------------------------------------------------------------------------------------+|# |@RID|@CLASS|name |status|roles |password |+----+----+------+-----+------+------+------------------------------------------------------------------------------------------------------+|0 |#5:0|OUser |admin|ACTIVE|[#4:0]|&#123;PBKDF2...|+----+----+------+-----+------+------+------------------------------------------------------------------------------------------------------+（roles是一个link） 查看#4:01234567orientdb &#123;db=demo&#125;&gt; select from #4:0+----+----+------+-----+-------------+----+------------------------------+|# |@RID|@CLASS|name |inheritedRole|mode|rules |+----+----+------+-----+-------------+----+------------------------------+|0 |#4:0|ORole |admin| |1 |&#123;database.bypassRestricted=31&#125;|+----+----+------+-----+-------------+----+------------------------------+ 将roles展开1234567orientdb &#123;db=demo&#125;&gt; select expand(roles) from #5:0+----+----+------+-----+-------------+----+------------------------------+|# |@RID|@CLASS|name |inheritedRole|mode|rules |+----+----+------+-----+-------------+----+------------------------------+|0 |#4:0|ORole |admin| |1 |&#123;database.bypassRestricted=31&#125;|+----+----+------+-----+-------------+----+------------------------------+ count1SELECT COUNT(*) FROM Account min/max/avg/sum1SELECT min(salary) FROM Account date()Syntax: date( &lt;date-as-string&gt; [&lt;format&gt;] [,&lt;timezone&gt;] )1SELECT FROM Account WHERE created &lt;= date(&apos;2012-07-02&apos;, &apos;yyyy-MM-dd&apos;) sysdate123456789orientdb &#123;db=demo&#125;&gt; SELECT sysdate(&apos;dd-MM-yyyy HH:mm:ss&apos;),roles FROM ouser+----+-------------------+------+|# |sysdate |roles |+----+-------------------+------+|0 |31-10-2017 17:33:57|[#4:0]||1 |31-10-2017 17:33:57|[#4:1]||2 |31-10-2017 17:33:57|[#4:2]|+----+-------------------+------+ format1SELECT format(&quot;%d - Mr. %s %s (%s)&quot;, id, name, surname, address) FROM Account distinct1SELECT distinct(name) FROM City unionall123456789101112131415161718orientdb &#123;db=demo&#125;&gt; select from orole +----+----+------+----+------+----------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+|# |@RID|@CLASS|mode|name |inheritedR|rules |+----+----+------+----+------+----------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+|0 |#4:0|ORole |1 |admin | |&#123;database.bypassRestricted=31&#125; ||1 |#4:1|ORole |0 |reader| |&#123;database.cluster.internal=2, database.cluster.orole=0, database=2, database.function=2, database.schema=2, database.class.ouser=0, database.cluster.ouser=0, database.system...||2 |#4:2|ORole |0 |writer| |&#123;database.cluster.internal=2, database=2, database.function=2, database.schema=2, database.class.ouser=0, database.systemclusters=0, database.cluster=31, database.command=31...|+----+----+------+----+------+----------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+orientdb &#123;db=demo&#125;&gt; select unionall(@class) as class,unionall(name) as name from orole+----+-------------------+---------------------+|# |class |name |+----+-------------------+---------------------+|0 |[ORole,ORole,ORole]|[admin,reader,writer]|+----+-------------------+---------------------+ Pagination(分页)1SELECT FROM &lt;target&gt; [WHERE ...] SKIP &lt;records-to-skip&gt; LIMIT &lt;max-records&gt;]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>orientDB</tag>
        <tag>nosql</tag>
        <tag>sql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OrientDB入门知识介绍]]></title>
    <url>%2F2017%2F10%2F31%2ForientDB%E5%85%A5%E9%97%A8%E7%9F%A5%E8%AF%86%E4%BB%8B%E7%BB%8D%2F</url>
    <content type="text"><![CDATA[orientdb基本概念orientDB是一个Document-Graph databases,是一个NoSql数据库，支持SQL查询; Recordrecord是数据查询和存储的最小单元，主要包括4种类型： Document： 文档数据库概念； RecordBytes： BLOB，二进制数据； Vertex： Graph 数据库概念； Edge： Graph 数据库概念； Record ID类似关系数据库中的主键，由orientDB自动分配；格式：1234#&lt;cluster&gt;:&lt;position&gt;cluster: 正数，表示持久化的record；cluster：负数，表示临时的record； Record Versionrecord的每一次更新操作，Record Version都会自增；在乐观锁事务中，通过Record Version 可以检测冲突； Class 面向对象中的概念； 类比关系型数据库中的表； 支持继承； 一个Class可以包含1个或多个Cluster，至少应包含1个Cluster； 当新建一个Class时，orientDB默认会创建N个Cluster(N：和Cpu核数相同)； 逻辑框架：组织数据（与Cluster作对比）； Cluster The Cluster is a place where a group of records are stored. 用于存储record，当新建一个record时，都会将该record存储到一个Cluster中； 物理或内存空间：真正存储数据（与Class作对比）； 可类比 Document数据库中的集合 或 关系型数据库中的表； 一个database最多可以有32767个Cluster； Class vs. Cluster in Queries正确理解Cluster Class包括2个Cluster 向Class中插入record（使用默认的Cluster） 查询数据（直接查询Class） 查询数据（直接查询Cluster） 示例说明： 1234Invoice是一个Class，该Class包含2个Cluster, 分别为 invoice2016、invoice2017；Class: Invoice （包含属性 year）；Cluster1: invoice2016, 存储2016年相关数据；Cluster2: invoice2017, 存储2017年相关数据； 则如下查询结果相同，但查询Cluster效率更高：12345// 查询 Classorientdb&gt; SELECT FROM Invoice WHERE year = 2016// 查询Cluster：效率更高orientdb&gt; SELECT FROM CLUSTER:invoice2016 RelationshipsRelationships介绍 关系型数据库中，一般使用Join来处理连接，如下图所示： 12mysql&gt; SELECT B.location FROM Customer A, Address B WHERE A.name='Luca' AND A.address=B.id; 12mysql&gt; SELECT B.location FROM Customer A, Address B WHERE A.name='Luca' AND B.customer=A.id; 12mysql&gt; SELECT C.location FROM Customer A, CustomerAddress B, Address C WHERE A.name='Luca' AND B.id=A.id AND B.address=C.id; 在关系型数据库中，多表连接查询时，使用JOIN语句(时间复杂度：O(log N / block_size))，而JOIN语句在数据量比较大时，相当耗时； 在OrientDB中，使用Link来管理连接，类似指针，查询时间为：O(1);orientdb支持两种relationships： referenced： embedded：Referenced Relationships 可以类比关系型数据库中的Join语句，但是比Join语句效率更高； 每个record都有rid； 1:1 and n:1 Referenced Relationships； 1:n and n:n Referenced Relationships；1234 customer Record A -------------&gt; Record BCLASS=Invoice CLASS=Customer RID=5:23 RID=10:2 record A contains the reference to record B in the property customer embedded Relationships 被嵌入的record没有rid； 1:1 and n:1 Embedded Relationships; 1:n and n:n Embedded Relationships; 1234 address Record A &lt;&gt;----------&gt; Record BCLASS=Account CLASS=Address RID=5:23 NO RID! record A contains the entirety of record B in the property address1orientdb&gt; SELECT FROM Account WHERE address.city = &apos;Rome&apos; DatabaseDatabase URL:&lt;engine&gt;:&lt;db-name&gt; plocal: This engine writes to the file system to store data. memory: Open a database completely in memory; remote: The storage will be opened via a remote network connection.remote:&lt;server&gt;:[&lt;port&gt;]/db-name ; orientdb vs 关系型数据库区别1： relational最重要的区别， orientDB没有Join，而是使用Link表示连接；12345678SELECT *FROM Employee A, City BWHERE A.city = B.idAND B.name = 'Rome'(关系型数据库)vs（orientDB）SELECT * FROM Employee WHERE city.name = 'Rome' 区别2: orientDB的*是可选的12345SELECT * FROM CustomervsSELECT FROM Customer 区别3： DISTINCT SQL: DISTINCT是关键字； OrientDB： DISTINCT是函数；12345SELECT DISTINCT name FROM CityvsSELECT DISTINCT(name) FROM City 区别4： HAVINGorientdb不支持Having；12345678SELECT city, sum(salary) AS salaryFROM EmployeeGROUP BY cityHAVING salary &gt; 1000vs SELECT FROM ( SELECT city, SUM(salary) AS salary FROM Employee GROUP BY city ) WHERE salary &gt; 1000 区别5： 多表查询orientDB查询：一次最多只支持一个Class查询，不支持类似：1SELECT FROM E, V (不支持) 区别6： metadataorientDB支持查询 metadata； schema, to get classes and properties indexmanager, to get information about indexes1234567891011121314151617select expand(classes) from metadata:schemaselect expand(properties) from ( select expand(classes) from metadata:schema) where name = 'OUser'select customFields from ( select expand(classes) from metadata:schema ) where name="OUser"elect customFields from ( select expand(properties) from ( select expand(classes) from metadata:schema ) where name="OUser") where name="password"select expand(indexes) from metadata:indexmanager orientDB相关文章Multi-master replicationDistributed ArchitectureDistributed-Sharding]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>orientDB</tag>
        <tag>nosql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[搭建github博客]]></title>
    <url>%2F2017%2F10%2F28%2F%E6%90%AD%E5%BB%BAgithub%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[搭建流程 安装node.js （默认会将npm一起安装） 安装hexo-cli: npm install hexo-cli -g ; 安装hexo-deployer-git：npm install hexo-deployer-git --save ; 然后是修改配置文件和安装主题等； 配置文件hexo和主题配置文件 主题安装使用next 主题贴标签 站点配置文件有配置：tag_dir: tags 主题配置文件有配置：tags: tags 新建tags页面： source/tags/index.md 123456---title: tagsdate: 2017-10-28 12:05:43type: &quot;tags&quot;comments: false--- 文章中添加tag： 123456title: TagEditTextdate: 2016-11-19 10:44:25tags: - Tag1 - Tag2 - Tag3 分类，给文章归档 站点配置文件有配置：category_dir: categories 主题配置文件有配置：categories: /categories 新建categories页面： source/categories/index.md 123456---title: categoriesdate: 2017-10-28 12:09:44type: &quot;categories&quot;comments: false--- 在文章中添加categories 1234title: TagEditTextdate: 2016-11-19 10:44:25categories: - cate 添加评论功能 （TODO） 采坑记录github的参考名称必须为xxx.github.io; ssh链接问题先产生ssh秘钥，然后将key添加到github上； deploy配置1234deploy: type: git repo: git@github.com:ssslinppp/ssslinppp.github.io.git branch: master ERROR Deployer not found: git执行下面的语句：1npm install hexo-deployer-git --save 然后重新执行：12hexo ghexo d 发布新文章只需要将xxx.md放到目录：source\_posts\下面，然后执行：123hexo cleanhexo ghexo d 参考链接Hexo 博客搭建指南Windows下GitHub + Hexo搭建个人博客]]></content>
      <categories>
        <category>install</category>
      </categories>
      <tags>
        <tag>github</tag>
        <tag>blog</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2017%2F10%2F28%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
